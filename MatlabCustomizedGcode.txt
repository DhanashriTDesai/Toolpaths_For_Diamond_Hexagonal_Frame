%%%% This code generates a Customized G-code for Uniform Hexagonal and Diamond frame structures %%%%
%%%% Customized tool-path is generated by defining a continuous nodal path with uniform flow rate %%
%%%% Written By Dhanashri Desai (3rd year,MTech(R),ME,IISc) during 1 Aug'22 to 10 Oct'22 for the fulfillment of MTech(R) Thesis %%%%
%%%% Modified by Jaydeep Pawar (2nd year,MTech,CSA,IISc) for generalization w.r.t. no of cells %%%%

%% Main function
%%% This function contains the parametric data for unit cell in the cellular frame structure, 
% which are passed as argumemnts to user-defined functions to generate eventually the G-code file %%%

clear; clc; close all; % Housekeeping commands
tCell=2; theta=60; rho_rel=0.30; % parameters of unit cell and relative density
nCellH=6; nCellV=5; % no of cells in horizontal and vertical direction 
CellType='StretchDominatedDiamond'; % StretchDominatedDiamond BendingDominatedHexagon
E0=5.87; dLdE=60; % initial feed rate (end value of prime tower Gcode) and uniform rate at which motor feed increases
nLayer=10; % no. of layers to be printed

% generate grid of nodes and elements
[LCell,Lh,Lv,nelem,nnodes,nodeID,nx,ny,Nrows,Ncolumns,LhDomain,LvDomain] = Generate2DGrid(CellType,nCellH,nCellV,tCell,rho_rel,theta);
% generate continuous nodal path
[NodalPath] = GenerateNodalPath(CellType,nnodes,nCellH,nCellV);
% generate uniform flow rate data according to nodal path
[E,nExtrusion] = GenerateFeedRate(CellType,E0,nelem,dLdE,LCell,Lv,LhDomain,LvDomain,nCellH,nCellV,Nrows,nLayer);
% generate G-code file
WriteToFile(CellType,NodalPath,nx,ny,E,nCellH,nCellV,nExtrusion,nLayer);


%% Generate2DGrid function
%%% This function generates 2D grid containing nodes and elements according to cell parameters and no. of cells %%%

function [LCell,Lh,Lv,nelem,nnodes,nodeID,nx,ny,Nrows,Ncolumns,LhDomain,LvDomain] = Generate2DGrid(CellType,nCellH,nCellV,tCell,rho_rel,theta)

switch CellType
    case 'StretchDominatedDiamond'
                    Nrows = 2*nCellH+1; Ncolumns = 2*nCellV+1; % no of rows and columns in the grid
                    LCell=round(2*sqrt(3)*tCell/rho_rel); % LCell=2*sqrt(3)*tCell/rho_rel theoretical relative density of diamond cell
                    Lh=LCell*cosd(theta); Lv=LCell*sind(theta); % horizontal and vertical components of LCell
                    x0=40+2*nCellV*Lv; y0=60; % start point for the printing 
                    nelem = 0; nnodes = 0;
                    
                    % Co-ordinates of nodes in odd rows
                    for i = 1:2:Nrows 
                        for j = 2:2:Ncolumns
                            nnodes = nnodes + 1;
                            nodeID(i,j) = ((i-1)*Ncolumns + j)/2;
                            nx(nodeID(i,j)) = x0 - Lv * (i-1);
                            ny(nodeID(i,j)) = y0 + Lh * (j-1);
                        end
                    end
                    
                    % Co-ordinates of nodes in even rows
                    for i = 2:2:Nrows 
                        for j = 1:2:Ncolumns
                            nnodes = nnodes + 1;
                            nodeID(i,j) = ((i-1)*Ncolumns + j)/2;
                            nx(nodeID(i,j)) = x0 - Lv * (i-1);
                            ny(nodeID(i,j)) = y0 + Lh * (j-1);        
                        end
                    end
                    
                    % Connect horizontal elements in odd rows
                    for i = 1:2:Nrows
                        for j = 2:2:(Ncolumns-2)
                            nelem = nelem + 1;
                            elemcon(nelem,1) = nodeID(i,j);
                            elemcon(nelem,2) = nodeID(i,j+2);
                        end
                    end
                    
                    % Connect horizontal elements in even rows
                    for i = 2:2:Nrows
                        for j = 1:2:(Ncolumns-2)
                            nelem = nelem + 1;
                            elemcon(nelem,1) = nodeID(i,j);
                            elemcon(nelem,2) = nodeID(i,j+2);
                        end
                    end
                            
                    % Connect inclined elements
                    for i = 1:2:(Nrows-1)
                        for j = 1:2:(Ncolumns-2)
                            nelem = nelem + 1;
                            elemcon(nelem,1) = nodeID(i,j+1);
                            elemcon(nelem,2) = nodeID(i+1,j);
                    
                            nelem = nelem + 1;
                            elemcon(nelem,1) = nodeID(i,j+1);
                            elemcon(nelem,2) = nodeID(i+1,j+2);
                        end
                    end       
                    
                    % Connect inclined elements
                    for i = 3:2:Nrows
                        for j = 1:2:(Ncolumns-2)
                            nelem = nelem + 1;
                            elemcon(nelem,1) = nodeID(i,j+1);
                            elemcon(nelem,2) = nodeID(i-1,j);
                    
                            nelem = nelem + 1;
                            elemcon(nelem,1) = nodeID(i,j+1);
                            elemcon(nelem,2) = nodeID(i-1,j+2);  
                        end
                    end
                           
                    % Connect remaining inclined elements
                    if (mod(Nrows,2)==0)
                        for i = 1:2:(Nrows-1)
                            nelem = nelem + 1;
                            elemcon(nelem,1) = nodeID(i,Ncolumns);
                            elemcon(nelem,2) = nodeID(i+1,Ncolumns-1);
                        end
                    
                        for i = 2:2:(Nrows-1)
                            nelem = nelem + 1;  
                            elemcon(nelem,1) = nodeID(i,Ncolumns-1);
                            elemcon(nelem,2) = nodeID(i+1,Ncolumns);  
                        end        
                    end
                    
                    figure(1)
                    for i = 1:nelem
                        node1 = elemcon(i,1); node2 = elemcon(i,2);
                        L(i) = sqrt((nx(node1)-nx(node2))^2 + (ny(node1)-ny(node2))^2);
                        plot([nx(node1) nx(node2)], [ny(node1) ny(node2)],'-r');
                        hold on
                    end
                    
                    % vertices of the rectangular domain
                    nx(nnodes+1)=nx(nnodes); ny(nnodes+1)=ny(1)-Lh; 
                    nx(nnodes+2)=nx(1); ny(nnodes+2)=ny(1)-Lh; 
                    nx(nnodes+3)=nx(1); ny(nnodes+3)=ny(nnodes)+Lh;
                    nx(nnodes+4)=nx(nnodes); ny(nnodes+4)=ny(nnodes)+Lh;
                    LhDomain=nx(nnodes+2)-nx(nnodes+1); LvDomain=ny(nnodes+4)-ny(nnodes+1);
                    
                    for i = 1:length(nx)
                        text(nx(i),ny(i),num2str(i),'Fontsize',14,'Color','k');
%                         text(nx(i),(ny(i)-5),num2str([nx(i) ny(i)]),'Fontsize',10,'Color','b');
                        plot(nx(i),ny(i),'b*',MarkerSize=4);
                        plot(nx(i),ny(i),'bo',MarkerSize=4);
                    end
                    axis equal; xlim([0 230]); ylim([0 230]); 

    case 'BendingDominatedHexagon'
            Nrows = 2*nCellV+1; Ncolumns = 2*nCellH+2; % no of rows and columns in the grid
            LCell=round(2/sqrt(3)*tCell/rho_rel);
            Lh = LCell*cosd(theta); Lv = LCell*sind(theta); % horizomtal and vertical lengths
            x0=40; y0=60; % start point for the printing 
            nelem = 0; nnodes = 0;
            
            % Co-ordinates of nodes in odd rows
            for i = 1:2:Nrows 
                for j = 4:4:Ncolumns
                    nnodes = nnodes + 1;
                    nodeID(i,j) = ((i-1)*Ncolumns+j)/2;
                    nx(nodeID(i,j)) = x0+(j/2)*Lh + (j/2-1)*LCell;
                    ny(nodeID(i,j)) = y0+Lv * (i-1);
                end
            
                for j = 5:4:Ncolumns
                    nnodes = nnodes + 1;
                    nodeID(i,j) = ((i-1)*Ncolumns+j+1)/2;
                    nx(nodeID(i,j)) = x0+(j-1)/2*(Lh+LCell);
                    ny(nodeID(i,j)) = y0+Lv * (i-1);
                end
            
                nnodes = nnodes + 1;
                nodeID(i,1) = (i-1)/2*Ncolumns + 1;
                nx(nodeID(i,1)) = x0;
                ny(nodeID(i,1)) = y0+Lv * (i-1);
            end
            
            % Co-ordinates of nodes in even rows
            for i = 2:2:Nrows 
                for j = 2:4:Ncolumns
                    nnodes = nnodes + 1;
                    nodeID(i,j) = ((i-1)*Ncolumns+j)/2;
                    nx(nodeID(i,j)) = x0+(j/2)*Lh + (j-2)/2*LCell;
                    ny(nodeID(i,j)) = y0+Lv * (i-1);        
                end
            
                for j = 3:4:Ncolumns
                    nnodes = nnodes + 1;
                    nodeID(i,j) = ((i-1)*Ncolumns+j+1)/2;
                    nx(nodeID(i,j)) = x0+(j-1)/2*(Lh+LCell);
                    ny(nodeID(i,j)) = y0+Lv * (i-1);        
                end
            end
            
            % additional nodes for tracing the domain
            if (mod(nCellH,2)==0)
                nx(nnodes+1)=nx(nnodes)+Lh; ny(nnodes+1)=ny(nnodes);
                nx(nnodes+2)=nx(nCellH+1)+Lh; ny(nnodes+2)=ny(1); 
                LhDomain=nx(nnodes+2)-nx(1); LvDomain=ny(nnodes+1)-ny(1); k=nnodes+2;
            else
                LhDomain=nx(nCellH+1)-nx(1); LvDomain=ny(nnodes)-ny(1); k=nnodes;
            end
            
            % Connect horizontal elements in odd rows
            for i = 1:2:Nrows
                for j = 4:4:(Ncolumns-1)
                    nelem = nelem + 1;
                    elemcon(nelem,1) = nodeID(i,j);
                    elemcon(nelem,2) = nodeID(i,j+1);
                end
            end
            
            % Connect horizontal elements in even rows
            for i = 2:2:Nrows
                for j = 2:4:(Ncolumns-1)
                    nelem = nelem + 1;
                    elemcon(nelem,1) = nodeID(i,j);
                    elemcon(nelem,2) = nodeID(i,j+1);
                end
            end
                    
            % Connect inclined elements in odd rows
            for i = 1:2:(Nrows-1)
                for j = 1:4:(Ncolumns-1)
                    nelem = nelem + 1;
                    elemcon(nelem,1) = nodeID(i,j);
                    elemcon(nelem,2) = nodeID(i+1,j+1);
                end
            
                for j = 4:4:Ncolumns
                    nelem = nelem + 1;
                    elemcon(nelem,1) = nodeID(i,j);
                    elemcon(nelem,2) = nodeID(i+1,j-1);
                end
            end  
            
            % Connect inclined elements in even rows
            for i = 2:2:Nrows
                for j = 2:4:Ncolumns
                    nelem = nelem + 1;
                    elemcon(nelem,1) = nodeID(i,j);
                    elemcon(nelem,2) = nodeID(i+1,j-1);
                end
            
                for j = 3:4:(Ncolumns-1)
                    nelem = nelem + 1;
                    elemcon(nelem,1) = nodeID(i,j);
                    elemcon(nelem,2) = nodeID(i+1,j+1);  
                end
            end
            
            % Plot the ground structure - elements + nodes
            figure(1)
            for i = 1:nelem
                node1 = elemcon(i,1); node2 = elemcon(i,2);
                L(i) = sqrt((nx(node1)-nx(node2))^2 + (ny(node1)-ny(node2))^2);
                plot([nx(node1) nx(node2)], [ny(node1) ny(node2)],'-r');
                hold on
            end
            
            for i = 1:k
                text(nx(i),ny(i),num2str(i),'Fontsize',14,'Color','k');
%                 text(nx(i)-15,ny(i)-5,num2str([nx(i) ny(i)]),'Fontsize',10,'Color','b');
                plot(nx(i),ny(i),'b*',MarkerSize=4);
                plot(nx(i),ny(i),'bo',MarkerSize=4);
            end
            axis equal; xlim([0 270]); ylim([0 270]);
end
end


%% GenerateNodalPath function
%%% This function generates a tool-path, according to no. of cells and nodal data,
% by defining a nodal-path such that entire 2D-frame structure is traced with minimal no. of brakes %%%

function [NodalPath] = GenerateNodalPath(CellType,nnodes,nCellH,nCellV)

NodalPath=[]; k=1;
switch CellType
    case 'StretchDominatedDiamond'                 
                    RectangularDomainNodalPath=[nnodes+1 nnodes+2 nnodes+3 nnodes+4 nnodes+1];
                    for i=1:size(RectangularDomainNodalPath,2)
                        NodalPath(k)=RectangularDomainNodalPath(i); k=k+1;
                    end
                    
                    HorizontalNodalPath=zeros(nCellH-1,nCellV); %NumOfHorizontalNodalPaths=nCellH-1 and LengthOfHorizontalPath=nCellV
                    for i=1:(nCellH-1)
                        for j=1:nCellV
                            HorizontalNodalPath(i,j)=2*i*nCellV+(j+i);
                            NodalPath(k)=HorizontalNodalPath(i,j); k=k+1;
                        end
                    end
                    
                    %  generalized zigzag path 
                    for itr=0:(nCellH-1)
                        if(rem(itr,2)==0)
                            i = itr*(2*nCellV+1)+1;
                            j = i+nCellV;
                            b = j+nCellV;
                            a = j-1;
                            while(a>=i || b>=j)
                                if(b>=j)
                                    NodalPath(k)=b; k=k+1;
                                end
                                if(a>=i)
                                    NodalPath(k)=a; k=k+1;
                                end
                                a=a-1; 
		                        b=b-1;
                            end
                            b = b+2;
                            while(b<=j+nCellV)
                                NodalPath(k)=b; k=k+1;
                                b=b+1;
                            end
                            i = j;
                            j = i+nCellV+1;
                            a = j-2;
                            b = j+nCellV-1;
                            while(a>=i || b>=j)
                                if(b>=j)
                                    NodalPath(k)=b; k=k+1;
                                end
                                if(a>=i)
                                    NodalPath(k)=a; k=k+1;
                                end
                                a=a-1;
                                b=b-1;
                            end
                        else
                            i = itr*(2*nCellV+1)+1;
                            j = i+nCellV;
                            a = i;
                            b = j;
                            while(a<i+nCellV || b<j+nCellV)
                                if(b<j+nCellV)
                                    NodalPath(k)=b; k=k+1;
                                end
                                if(a<i+nCellV)
                                    NodalPath(k)=a; k=k+1;
                                end
                                a=a+1;
                                b=b+1;
                            end
                            b = b;
                            while(j<b)
                                NodalPath(k)=b; k=k+1;
                                b=b-1;
                            end
                            i = j;
                            j = i+nCellV+1;
                            a = i;
                            b = j;
                            while(a<i+nCellV+1 || b<j+nCellV)
                                if(a<i+nCellV+1)
                                    NodalPath(k)=a; k=k+1;
                                end
                                if(b<j+nCellV)
                                    NodalPath(k)=b; k=k+1;
                                end
                                a=a+1;
                                b=b+1;
                            end
                        end
                    end
                    
    case 'BendingDominatedHexagon'
                    if (mod(nCellH,2)==0)
                        RectangularDomainNodalPath=[1 (nnodes+2) (nnodes+1) (nnodes-nCellH) 1];
                    else
                        RectangularDomainNodalPath=[1 (nCellH+1) nnodes (nnodes-nCellH) 1];
                    end
                    
                    for i=1:size(RectangularDomainNodalPath,2)
                        NodalPath(k)=RectangularDomainNodalPath(i); k=k+1;
                    end
                    
                    % generalized zigzag path 
                    if (mod(nCellH,2)==0)
                            i = 0; j = 0; jump = fix(nCellH/2)*2+1;
                            for itr=1:nCellV
                                i = i+jump;
                                a = i+1;
                                b = i-jump+2;
                                alim = i+jump-1;
                                blim = i;
                        
                                while(a<=alim || b<=blim)
                                    if(a<=alim)
                                        NodalPath(k) = a; k=k+1;
                                    end
                                    a=a+1;
                                    if(a<=alim)
                                        NodalPath(k) = a; k=k+1;
                                    end
                                   
                                    if(b<=blim)
                                        NodalPath(k) = b; k=k+1;
                                    end
                                    b=b+1;
                                    if(b<=blim)
                                        NodalPath(k) = b; k=k+1;
                                    end
                                    a=a+1;
                                    b=b+1;
                                end
                        
                                i = i+jump;
                                a = i+jump;
                                b = i;
                                alim = i+1;
                                blim = i-jump+1;
                                
                                while(a>=alim || b>=blim)
                                    if(b>=blim)
                                        NodalPath(k) = b; k=k+1;
                                    end
                                    b=b-1;
                                    if(a>=alim)
                                        NodalPath(k) = a; k=k+1;
                                    end
                                    a=a-1;
                                    if(a>=alim)
                                        NodalPath(k) = a; k=k+1;
                                    end    
                                    if(b>=blim)
                                        NodalPath(k) = b; k=k+1;
                                    end
                                    a=a-1;
                                    b=b-1;
                                end
                            end

                    else
                                i = 0; j = 0; jump = fix(nCellH/2)*2+2;
                                for itr=1:nCellV
                                    i = i+jump;
                                    a = i+1;
                                    b = i-jump+2;
                            
                                    while(a<=i+jump && b<=i)
                                        NodalPath(k) = a; k=k+1;
                                        a=a+1;
                                        if(a<=i+jump)
                                            NodalPath(k) = a; k=k+1;
                                        end
                                        NodalPath(k) = b; k=k+1;
                                        b=b+1;
                                        if(b<=i)
                                            NodalPath(k) = b; k=k+1;
                                        end
                                        a=a+1;
                                        b=b+1;
                                    end

                                    i = i+jump;
                                    a = i+jump;
                                    b = i;
                                    NodalPath(k) = a; k=k+1;
                                    a=a-1;
                                    
                                    while(a>=i+1 && b>=i-jump+1)
                                        NodalPath(k) = b; k=k+1;
                                        b=b-1;
                                        if(b>=i-jump+1)
                                            NodalPath(k) = b; k=k+1;
                                        end
                                        NodalPath(k) = a; k=k+1;
                                        a=a-1;
                                        if(a>=i+1)
                                            NodalPath(k) = a; k=k+1;
                                        end
                                        a=a-1;
                                        b=b-1;
                                    end

                                end
                    end

end
NodalPath=NodalPath';
end


%% GenerateFeedRate function
%%% This function generates the feed rate data according to cell parameters, no. of cells and no. of layers
% by incrementing the extrusion co-rdinate (E) through constant value %%%

function [E,nExtrusion] = GenerateFeedRate(CellType,E0,nelem,dLdE,LCell,Lv,LhDomain,LvDomain,nCellH,nCellV,Nrows,nLayer)

switch CellType
    case 'StretchDominatedDiamond'
                % Generate feed rate data for print path
                nExtrusion=nelem-2*(nCellV-1)+4; % no of extrusion moves
                
                for i=1:nLayer
                    for j=1:nExtrusion
                        if i==1 && j==1
                            E((i-1)*nExtrusion+j)=E0+LhDomain/dLdE;
                        elseif j==1 || j==3
                            E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LhDomain/dLdE;
                        elseif j==2 || j==4
                            E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LvDomain/dLdE;
                        else 
                            E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LCell/dLdE;
                        end
                    end
                end

    case 'BendingDominatedHexagon'
                % Generate feed rate data for print path
                nHorizontalDoubleExtrusion=0;
                if mod(nCellH,2)==0
                    for i=2:(Nrows-1)
                        nHorizontalDoubleExtrusion=nHorizontalDoubleExtrusion+fix(nCellH/2);
                    end
                else
                    for i=2:(Nrows-1)
                        if mod(i,2)==0
                            nHorizontalDoubleExtrusion=nHorizontalDoubleExtrusion + (fix(nCellH/2)+1);
                        else
                            nHorizontalDoubleExtrusion=nHorizontalDoubleExtrusion + fix(nCellH/2);
                        end
                    end
                end
                
                if(mod(nCellH,2)==1)
                    nExtrusion=nelem+4+nHorizontalDoubleExtrusion+nCellV; % no of extrusion moves
                    jump(1)=5+(2*nCellH+1);
                    for i=2:nCellV
                        jump(i) = jump(i-1) + 2*(2*nCellH+1) + 1;
                    end
                    for i=1:nLayer
                        for j=1:nExtrusion
                            if i==1 && j==1
                                E((i-1)*nExtrusion+j)=E0+LhDomain/dLdE;
                            elseif j==1 || j==3
                                E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LhDomain/dLdE;
                            elseif j==2 || j==4
                                E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LvDomain/dLdE;
                            elseif ismember(j,jump)
                                E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+ (2*Lv/dLdE);
                            else 
                                E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LCell/dLdE;
                            end
                        end
                    end

                else
                    nExtrusion=nelem+4+nHorizontalDoubleExtrusion; % no of extrusion moves
                    for i=1:nLayer
                        for j=1:nExtrusion
                            if i==1 && j==1
                                E((i-1)*nExtrusion+j)=E0+LhDomain/dLdE;
                            elseif j==1 || j==3
                                E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LhDomain/dLdE;
                            elseif j==2 || j==4
                                E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LvDomain/dLdE;
                            else 
                                E((i-1)*nExtrusion+j)=E((i-1)*nExtrusion+j-1)+LCell/dLdE;
                            end
                        end
                    end
                end

end
E=E';
end


%% WriteToFile function
%%% This function generates the G-code file according to the nodal path and feed rate data %%%

function WriteToFile(CellType,NodalPath,nx,ny,E,nCellH,nCellV,nExtrusion,nLayer)

switch CellType
    case 'StretchDominatedDiamond'
        fileID = fopen('DiamondCellGcode.gcode','w'); 
    case 'BendingDominatedHexagon'
        fileID = fopen('HexagonalCellGcode.gcode','w'); 
end

% Initial house-keeping commands
fprintf(fileID,strcat(';FLAVOR:Marlin','\n',';TIME:6','\n',';Layer height: 2','\n',';MINX:10','\n',';MINY:0', ...
    '\n',';MINZ:2','\n',';MAXX:240','\n',';MAXY:230','\n',';MAXZ:2','\n','T1','\n','M140 S70','\n','M105','\n','M190 S70','\n','M105','\n','M82 ;absolute extrusion mode', ...
    '\n','G21 ;metric values','\n','M107','\n','G28','\n','M420 S1','\n','G90 ;absolute positioning','\n','G92 E0; reset extruder distance', ...
    '\n','G1 X0 Y0 Z10 F5000 ;move nozzle up 10mm for safe homing','\n','M500','\n','M82 ;set extruder to absolute mode', ...
    '\n','M107 ;start with the fan off','\n','G92 E0 ;zero the extruded length','\n','M117 Printing...','\n','G92 E0','\n','G92 E0' ...
    ,'\n',';LAYER_COUNT:1','\n',';LAYER:0','\n','M107','\n','\n','\n','\n','\n')); 

% Prime tower gcode - generated using Ultimaker CURA
fprintf(fileID,strcat('\n','\n','\n','\n','\n',';MESH:SlurryPrimeTower.stl','\n','G0 F3600 X16.778 Y13.684 Z2', ...
    '\n',';TYPE:WALL-OUTER','\n','G1 F420 X20.677 Y11.697 E0.07278','\n','G1 X25 Y11.013 E0.14556', ...
    '\n','G1 X29.323 Y11.697 E0.21835','\n','G1 X33.222 Y13.684 E0.29112','\n','G1 X36.316 Y16.778 E0.36389', ...
    '\n','G1 X38.303 Y20.677 E0.43666','\n','G1 X38.987 Y25 E0.50945','\n','G1 X38.303 Y29.323 E0.58224', ...
    '\n','G1 X36.316 Y33.222 E0.65501','\n','G1 X33.222 Y36.316 E0.72778','\n','G1 X29.323 Y38.303 E0.80055', ...
    '\n','G1 X25 Y38.987 E0.87334','\n','G1 X20.677 Y38.303 E0.94612','\n','G1 X16.778 Y36.316 E1.0189', ...
    '\n','G1 X13.684 Y33.222 E1.09167','\n','G1 X11.697 Y29.323 E1.16444','\n','G1 X11.013 Y25 E1.23723' ...
    ,'\n','G1 X11.697 Y20.677 E1.31001','\n','G1 X13.684 Y16.778 E1.38279','\n','G1 X16.778 Y13.684 E1.45555', ...
    '\n','G0 F3600 X17.668 Y13.23','\n','G0 X17.962 Y15.314','\n',';TYPE:SKIN','\n','G1 F420 X21.299 Y13.614 E1.51783', ...
    '\n','G1 X25 Y13.029 E1.58015','\n','G1 X28.701 Y13.614 E1.64246' ...
    ,'\n','G1 X32.038 Y15.314 E1.70474','\n','G1 X34.686 Y17.962 E1.76702','\n','G1 X36.386 Y21.299 E1.8293', ...
    '\n','G1 X36.971 Y25 E1.89161','\n','G1 X36.386 Y28.701 E1.95392','\n','G1 X34.686 Y32.038 E2.0162', ...
    '\n','G1 X32.038 Y34.686 E2.07848','\n','G1 X28.701 Y36.386 E2.14076',...
    '\n','G1 X25 Y36.971 E2.20307','\n','G1 X21.299 Y36.386 E2.26538','\n','G1 X17.962 Y34.686 E2.32766', ...
    '\n','G1 X15.314 Y32.038 E2.38994','\n','G1 X13.614 Y28.701 E2.45222','\n','G1 X13.029 Y25 E2.51453', ...
    '\n','G1 X13.614 Y21.299 E2.57685','\n','G1 X15.314 Y17.962 E2.63913' ...
    ,'\n','G1 X17.962 Y15.314 E2.7014','\n','G0 F3600 X19.151 Y16.953','\n','G1 F420 X21.926 Y15.539 E2.7532', ...
    '\n','G1 X25 Y15.053 E2.80495', ...
    '\n','G1 X28.074 Y15.539 E2.85671','\n','G1 X30.849 Y16.953 E2.9085','\n','G1 X33.047 Y19.151 E2.9602', ...
    '\n','G1 X34.461 Y21.926 E3.01199','\n','G1 X34.947 Y25 E3.06375','\n','G1 X34.461 Y28.074 E3.1155' ...
    ,'\n','G1 X33.047 Y30.849 E3.1673','\n','G1 X30.849 Y33.047 E3.21899','\n','G1 X28.074 Y34.461 E3.27079', ...
    '\n','G1 X25 Y34.947 E3.32254', ...
    '\n','G1 X21.926 Y34.461 E3.3743','\n','G1 X19.151 Y33.047 E3.42609','\n','G1 X16.953 Y30.849 E3.47778', ...
    '\n','G1 X15.539 Y28.074 E3.52958','\n','G1 X15.053 Y25 E3.58133','\n','G1 X15.539 Y21.926 E3.63309' ...
    ,'\n','G1 X16.953 Y19.151 E3.68488','\n','G1 X19.151 Y16.953 E3.73658','\n','G0 F3600 X27.706 Y16.392', ...
    '\n','G1 F420 X33.607 Y22.293 E3.87536','\n','G0 F3600 X33.96 Y25.474', ...
    '\n','G1 F420 X24.525 Y16.04 E4.09725','\n','G0 F3600 X22.111 Y16.455','\n','G1 F420 X33.545 Y27.888 E4.36614', ...
    '\n','G0 F3600 X32.59 Y29.762','\n','G1 F420 X20.237 Y17.408 E4.65668' ...
    ,'\n','G0 F3600 X18.687 Y18.687','\n','G1 F420 X31.311 Y31.311 E4.95358','\n','G0 F3600 X29.761 Y32.589', ...
    '\n','G1 F420 X17.408 Y20.236 E5.2441','\n','G0 F3600 X16.454 Y22.111' ...
    ,'\n','G1 F420 X27.887 Y33.544 E5.51299','\n','G0 F3600 X25.474 Y33.959','\n','G1 F420 X16.039 Y24.524 E5.73488', ...
    '\n','G0 F3600 X16.392 Y27.705','\n','G1 F420 X22.292 Y33.606 E5.87365' ...
    ,'\n','G1 X22.645 Y33.959','\n','\n','\n','\n','\n'));

switch CellType
    case 'StretchDominatedDiamond'
            % Co-ordinate and feedrate data according to underlying structure - Customised according to Nodal path
            fprintf(fileID,strcat(';Coordinate data for diamond frame structure','\n'));
            NonExtrusionNodes=[1 6 6+nCellV*(nCellH-1)]; l=4;
            for m=1:(nCellH-2)
                NonExtrusionNodes(l)=6+m*nCellV; l=l+1;
            end
            for n=1:(nCellH-1)
                NonExtrusionNodes(l)=6+nCellV*(nCellH-1)+n*(5*nCellV+1); l=l+1;
            end
            for i=1:nLayer
                fprintf(fileID,strcat(';Layer',num2str(i),' Z',num2str(2*i),'\n'));
                k=(i-1)*nExtrusion+1;
                for j=1:size(NodalPath,1)
                    if ismember(j,NonExtrusionNodes)
                        fprintf(fileID,strcat('G0',' F3600',' X',num2str(nx(NodalPath(j))),' Y',num2str(ny(NodalPath(j))),'\n')); 
                    else
                        fprintf(fileID,strcat('G1',' F420',' X',num2str(nx(NodalPath(j))),' Y',num2str(ny(NodalPath(j))),' E',num2str(E(k)),'\n')); k=k+1;
                    end
                end 
                % time gap 5 minutes
                if i<nLayer
                            fprintf(fileID,strcat('\n','\n','\n','\n',';Interlayer time gap','\n', ...
                                          'G0',' F3600',' X',num2str(nx(NodalPath(1))),' Y',num2str(ny(NodalPath(1))),' Z',num2str(2*(i+1)),'\n', ...
                                           'G91','\n','G1',' Z200','\n','G4',' S300','\n','G1',' Z-200','\n','G90','\n','\n','\n','\n','\n'));
                end
            end
                        
                       
                      
                        
    case 'BendingDominatedHexagon'
                % Co-ordinate and feedrate data according to underlying structure - Customised according to Nodal path
                fprintf(fileID,strcat(';Coordinate data for diamond frame structure','\n'));
                        for i=1:nLayer
                            fprintf(fileID,strcat(';Layer',num2str(i),' Z',num2str(2*i),'\n'));
                            k=(i-1)*nExtrusion+1;
                            fprintf(fileID,strcat('G0',' F3600',' X',num2str(nx(NodalPath(1))),' Y',num2str(ny(NodalPath(1))),'\n')); 
                            if mod(nCellH,2)==1
                                for j=2:size(NodalPath,1)
                                    fprintf(fileID,strcat('G1',' F420',' X',num2str(nx(NodalPath(j))),' Y',num2str(ny(NodalPath(j))),' E',num2str(E(k)),'\n')); k=k+1;
                                end
                            else
                                for j=2:size(NodalPath,1)
                                    fprintf(fileID,strcat('G1',' F420',' X',num2str(nx(NodalPath(j))),' Y',num2str(ny(NodalPath(j))),' E',num2str(E(k)),'\n')); k=k+1;
                                end
                            end
                            
                            % time gap 5 minutes
                            if i<nLayer
                                fprintf(fileID,strcat('\n','\n','\n','\n',';Interlayer time gap','\n', ...
                                              'G0',' F3600',' X',num2str(nx(NodalPath(1))),' Y',num2str(ny(NodalPath(1))),' Z',num2str(2*(i+1)),'\n', ...
                                               'G91','\n','G1',' Z200','\n','G4',' S300','\n','G1',' Z-200','\n','G90','\n','\n','\n','\n','\n'));
                            end
                
                        end    
end

% Final house-keeping commands
fprintf(fileID,strcat('\n','\n','\n','\n','\n',';End GCode','\n','M140 S0 ;heated bed heater off (if you have it)', ...
    '\n','G91 ;relative positioning','\n','G28;move X/Y to min endstops, so the head is out of the way','\n','M84 ;steppers off', ...
    '\n','M107','\n','G90 ;absolute positioning','\n','M82 ;absolute extrusion mode','\n',';End of Gcode'));

fclose(fileID);

% Open G-code file using Ultimaker Cura
switch CellType
    case 'StretchDominatedDiamond'
        winopen('DiamondCellGcode.gcode'); 
    case 'BendingDominatedHexagon'
        winopen('HexagonalCellGcode.gcode');
end
end


%%